Write a function that searches a list of names (unsorted) for the name "Bob" and returns the location in the list. If Bob is not in the array, return -1.

Examples:

csWhereIsBob(["Jimmy", "Layla", "Bob"]) ➞ 2
csWhereIsBob(["Bob", "Layla", "Kaitlyn", "Patricia"]) ➞ 0
csWhereIsBob(["Jimmy", "Layla", "James"]) ➞ -1
Notes:

Assume all names start with a capital letter and are lowercase thereafter (i.e. don't worry about finding "BOB" or "bob").

********** CODE ************

def csWhereIsBob(names):
    bob = "Bob"
    if bob in names:
        return names.index(bob)
    else:
        return -1
        
*********** CODE ***************

Create a function that returns True if the given string has any of the following:

Only letters and no numbers.
Only numbers and no letters.
If a string has both numbers and letters or contains characters that don't fit into any category, return False.

Examples:

csAlphanumericRestriction("Bold") ➞ True
csAlphanumericRestriction("123454321") ➞ True
csAlphanumericRestriction("H3LL0") ➞ False
Notes:

Any string that contains spaces or is empty should return False.

*********** CODE ***************

def csAlphanumericRestriction(input_str):
    if input_str.isalpha() or input_str.isdigit():
        return True
    else:
        return False

*********** CODE ***************

Write a function that takes a string as input and returns that string in reverse order, with the opposite casing for each character within the string.

Examples:

csOppositeReverse("Hello World") ➞ "DLROw OLLEh"
csOppositeReverse("ReVeRsE") ➞ "eSrEvEr"
csOppositeReverse("Radar") ➞ "RADAr"
Notes:

The input string will only contain alpha characters.

*********** CODE ***************

def csOppositeReverse(txt):
    a = txt[::-1]
    return a.swapcase()

*********** CODE ***************

Create a function that given an integer, returns an integer where every digit in the input integer is squared.

Examples:

csSquareAllDigits(9119) -> 811181 because 9^2 = 81, 1^2 = 1, 1^2 = 1, and 9^2 = 81
csSquareAllDigits(2483) -> 416649 because 2^2 = 4, 4^2 = 16, 8^2 = 64, and 3^2 = 9

*********** CODE ***************

def csSquareAllDigits(n):
    res = ""
    for ch in str(n):
        res = res + str(int(ch)**2)
    return int(res)

*********** CODE ***************

Imagine a school that children attend for years. In each year, there are a certain number of groups started, marked with the letters. So if years = 7 and groups = 4For the first year, the groups are 1a, 1b, 1c, 1d, and for the last year, the groups are 7a, 7b, 7c, 7d.

Write a function that returns the groups in the school by year (as a string), separated with a comma and space in the form of "1a, 1b, 1c, 1d, 2a, 2b (....) 6d, 7a, 7b, 7c, 7d".

Examples:

csSchoolYearsAndGroups(years = 7, groups = 4) ➞ "1a, 1b, 1c, 1d, 2a, 2b, 2c, 2d, 3a, 3b, 3c, 3d, 4a, 4b, 4c, 4d, 5a, 5b, 5c, 5d, 6a, 6b, 6c, 6d, 7a, 7b, 7c, 7d"
Notes:

1 <= years <= 10
1 <= groups <=26

*********** CODE ***************

def csSchoolYearsAndGroups(years, groups):
    my_list = []
    for x in range(years):
        x += 1
        x_iteration = str(x)
        letter = ord("a")
        for y in range(groups):
            y += 1
            y_iteration = chr(letter)
            xy_iteration = x_iteration + y_iteration
            my_list.append(xy_iteration)
            letter += 1
    return ", ".join(map(str, my_list))

*********** CODE ***************

Create a function that concatenates the number 7 to the end of every chord in a list. If a chord already ends with a 7, do not add another 7.

Examples:

csMakeItJazzy(["G", "F", "C"]) ➞ ["G7", "F7", "C7"]
csMakeItJazzy(["G", "F7", "C"]) ➞ ["G7", "F7", "C7"]
csMakeItJazzy(["Dm", "G", "E", "A"]) ➞ ["Dm7", "G7", "E7", "A7"]
csMakeItJazzy(["F7", "E7", "A7", "Ab7", "Gm7", "C7"]) ➞ ["F7", "E7", "A7", "Ab7", "Gm7", "C7"]
csMakeItJazzy([]) ➞ []
Notes:

Return an empty list if the given list is empty.
You can expect all the tests to have valid chords.

*********** CODE ***************

def csMakeItJazzy(chords):
    if not chords:
        return chords
    else:
      i = 0
      for chord in chords:
        last = chord[-1]
        if ord(last) == 55:
          pass
        else:
            new_chord = chord + str(7)
            chords[i] = new_chord
        i += 1
    return(chords)

*********** CODE ***************

Given a string, return a new string with all the vowels removed.

Examples:

csRemoveTheVowels("Lambda School is awesome!") -> "Lmbd Schl s wsm!"
Notes:

For this challenge, "y" is not considered a vowel.
[execution time limit] 4 seconds (py3)

[input] string input_str

[output] string

[Python 3] Syntax Tips

# Prints help message to the console
# Returns a string
def helloWorld(name):
    print "This prints to the console when you Run Tests"
    return "Hello, " + name

*********** CODE ***************

def csRemoveTheVowels(input_str):
    vowels = ("A", "a", "E", "e", "I", "i", "O", "o", "U", "u")
    for x in input_str:
        if x in vowels:
            input_str = input_str.replace(x, "")
    return input_str

*********** CODE ***************

Given a start integer and an ending integer (both inclusive), write a function that returns the count (not the sum) of all integers in the range (except integers that contain the digit 5).

Examples:

csAnythingButFive(1, 5) -> 1, 2, 3, 4, -> 4 (there are 4 integers in the range that do not contain the digit 5)
csAnythingButFive(1, 9) -> 1, 2, 3, 4, 6, 7, 8, 9 -> 8
csAnythingButFive(4, 17) -> 4,6,7,8,9,10,11,12,13,14,16,17 -> 12
Notes:

The output can contain the digit 5.
The start number will always be less than the end number (both numbers can also be negative).

*********** CODE ***************

def csAnythingButFive(start, end):
    x = range(start, end + 1)
    counter = 0
    for i in x:
        if "5" not in str(i):
            counter += 1
    return counter

*********** CODE ***************

Given an array of integers, return the sum of all the positive integers in the array.

Examples:

csSumOfPositive([1, 2, 3, -4, 5]) -> 1 + 2 + 3 + 5 = 11
csSumOfPositive([-3, -2, -1, 0, 1]) -> 1
csSumOfPositive([-3, -2]) -> 0
Notes:

If the input_arr does not contain any positive integers, the default sum should be 0.

*********** CODE ***************

def csSumOfPositive(input_arr):
    runningTotal = 0
    for x in input_arr:
        if x > 0:
            runningTotal = runningTotal + x
    return runningTotal

*********** CODE ***************

Given a string of words, return the length of the shortest word(s).

Notes:

The input string will never be empty and you do not need to validate for different data types.

*********** CODE ***************

def csShortestWord(input_str):
    x = list(map(len, input_str.split()))
    return min(x)

*********** CODE ***************

Given a sorted array (in ascending order) of integers and a target, write a function that finds the two integers that add up to the target.

Examples:

csSortedTwoSum([3,8,12,16], 11) -> [0,1]
csSortedTwoSum([3,4,5], 8) -> [0,2]
csSortedTwoSum([0,1], 1) -> [0,1]
Notes:

Each input will have exactly one solution.
You may not use the same element twice.

*********** CODE ***************

def csSortedTwoSum(numbers, target):
    for i in range(len(numbers) - 1):
        for j in range(i + 1, len(numbers)):
            if numbers[i] + numbers[j] == target:
                return [i, j]

*********** CODE ***************

You are given two strings, str_1 and str_2, where str_2 is generated by randomly shuffling str_1 and then adding one letter at a random position.

Write a function that returns the letter that was added to str_2.

Examples:

csFindAddedLetter(str_1 = "bcde", str_2 = "bcdef") -> "f"
csFindAddedLetter(str_1 = "", str_2 = "z") -> "z"
csFindAddedLetter(str_1 = "b", str_2 = "bb") -> "b"
csFindAddedLetter(str_1 = "bf", str_2 = "bfb") -> "b"
Notes:

str_1 and str_2 both consist of only lowercase alpha characters.

*********** CODE ***************

def csFindAddedLetter(str_1, str_2):
    i = list(str_1)
    j = list(str_2)
    
    j.sort()
    for x in i:
        j.remove(x)
    return "".join(j)

*********** CODE ***************

Given a string, write a function that returns the index of the first unique (non-repeating) character. If there isn't a unique (non-repeating) character, return -1.

Examples:

csFirstUniqueChar(input_str = "lambdaschool") -> 2
csFirstUniqueChar(input_str = "ilovelambdaschool") -> 0
csFirstUniqueChar(input_str = "vvv") -> -1
Notes:

input_str will only contain lowercase alpha characters.

*********** CODE ***************

def csFirstUniqueChar(input_str):
    orig = list(input_str)
    seen = []
    
    for i, j in enumerate(input_str):
        orig = orig[1:]
        if j not in orig and j not in seen:
            return i
        seen.append(input_str[i])
    return -1

*********** CODE ***************

Given two strings that include only lowercase alpha characters, str_1 and str_2, write a function that returns a new sorted string that contains any character (only once) that appeared in str_1 or str_2.

Examples:

csLongestPossible("aabbbcccdef", "xxyyzzz") -> "abcdefxyz"
csLongestPossible("abc", "abc") -> "abc"

*********** CODE ***************

def csLongestPossible(str_1, str_2):
    new_str = []
    for i in str_1:
        if i not in new_str:
            new_str.append(i)
    for j in str_2:
        if j not in new_str:
            new_str.append(j)
    new_str.sort()
    listToString = "".join(map(str, new_str))
    return listToString

*********** CODE ***************

You are given the prices of a stock, in the form of an array of integers, prices. Let's say that prices[i] is the price of the stock on the ith day (0-based index). Assuming that you are allowed to buy and sell the stock only once, your task is to find the maximum possible profit (the difference between the buy and sell prices).

Note: You can assume there are no fees associated with buying or selling the stock.

Example

For prices = [6, 3, 1, 2, 5, 4], the output should be buyAndSellStock(prices) = 4.

It would be most profitable to buy the stock on day 2 and sell it on day 4. Thus, the maximum profit is prices[4] - prices[2] = 5 - 1 = 4.

For prices = [8, 5, 3, 1], the output should be buyAndSellStock(prices) = 0.

Since the value of the stock drops each day, there's no way to make a profit from selling it. Hence, the maximum profit is 0.

For prices = [3, 100, 1, 97], the output should be buyAndSellStock(prices) = 97.

It would be most profitable to buy the stock on day 0 and sell it on day 1. Thus, the maximum profit is prices[1] - prices[0] = 100 - 3 = 97.

*********** CODE ***************

def buyAndSellStock(prices):
    minSell = 0
    maxSell = 1
    minBuy = 0
    maxProfit = 0
    
    if len(prices) > 2:    
        for i, j in enumerate(prices):
            if (prices[i] < prices[minBuy]):
                minBuy = i
            if (prices[maxSell] - prices[minSell] < prices[i] - prices[minBuy]):
                maxSell = i
                minSell = minBuy
        
        maxProfit = prices[maxSell] - prices[minSell]
    return maxProfit

*********** CODE ***************

Given a string, your task is to replace each of its characters by the next one in the English alphabet; i.e. replace a with b, replace b with c, etc (z would be replaced by a).

Example

For inputString = "crazy", the output should be alphabeticShift(inputString) = "dsbaz".

*********** CODE ***************

def alphabeticShift(inputString):
    a=ord('a')
    alph=[chr(i) for i in range(a, a+26)]
    str_list = list(inputString)
    new_arr = []
    
    for l in str_list:
        if l in alph and l != "z":
            inx = alph.index(l, 0, 27)
            nextLetter = alph[inx + 1]
            new_arr.append(nextLetter)
        else:
            new_arr.append(alph[0])
        answer = "".join(new_arr)
    return answer

*********** CODE ***************

You are given a parentheses sequence, check if it's regular.

Example

For s = "()()(())", the output should be
validParenthesesSequence(s) = true;
For s = "()()())", the output should be
validParenthesesSequence(s) = false.

*********** CODE ***************

def validParenthesesSequence(s):
    openList = ["("]
    closedList = [")"]
    newList = []
    
    for i in s:
        if i in openList:
            newList.append(i)
        elif i in closedList:
            pos = closedList.index(i)
            if ((len(newList) > 0) and 
                (openList[pos] == newList[len(newList) - 1])):
                newList.pop()
            else:
                return False
    if len(newList) == 0:
        return True
    else:
        return False  

*********** CODE ***************

Given a string (the input will be in the form of an array of characters), write a function that returns the reverse of the given string.

Examples:

csReverseString(["l", "a", "m", "b", "d", "a"]) -> ["a", "d", "b", "m", "a", "l"]
csReverseString(["I", "'", "m", " ", "a", "w", "e", "s", "o", "m", "e"]) -> ["e", "m", "o", "s", "e", "w", "a", " ", "m", "'", "I"]

*********** CODE ***************

def csReverseString(chars):
    reversedString = chars[::-1]
    return reversedString

*********** CODE ***************

A palindrome is a word, phrase, number, or another sequence of characters that reads the same backward or forward. This includes capital letters, punctuation, and other special characters.

Given a string, write a function that checks if the input is a valid palindrome.

Examples:

csCheckPalindrome("racecar") -> true
csCheckPalindrome("anna") -> true
csCheckPalindrome("12345") -> false
csCheckPalindrome("12321") -> true

*********** CODE ***************

def csCheckPalindrome(input_str):
    return input_str == input_str[::-1]
    
            ***OR***
            
def csCheckPalindrome(input_str):
    firstChar = 0
    lastChar = len(input_str) - 1
    isPalindrome = True
    for i in range(len(input_str)) :
        firstChar = firstPos(input_str, firstChar, lastChar);
        lastChar = lastPos(input_str, lastChar, firstChar);
        if (lastChar < 0 or firstChar < 0):
            break
        if (input_str[firstChar] == input_str[lastChar]):
            firstChar += 1
            lastChar -= 1
            continue
        isPalindrome = False
        break  
    return isPalindrome
    
# Helper function to get the position of first character in the string
def firstPos(input_str, start, end):
    firstChar = -1
    for i in range(start, end + 1):
        if (input_str[i] >= 'a' and input_str[i] <= 'z') :
            firstChar = i
            break  
    return firstChar

# Helper function to get the position of last character in the string
def lastPos(input_str, start, end):  
    lastChar = -1  
    for i in range(start, end - 1, -1) :
        if (input_str[i] >= 'a' and input_str[i] <= 'z') :
            lastChar = i
            break  
    return lastChar

*********** CODE ***************

Given a string, write a function that removes all duplicate words from the input. The string that you return should only contain the first occurrence of each word in the string.

Examples:

`csRemoveDuplicateWords("alpha bravo bravo golf golf golf delta alpha bravo bravo golf golf golf delta") -> "alpha bravo golf delta"
`csRemoveDuplicateWords("my dog is my dog is super smart") -> "my dog is super smart"

*********** CODE ***************

def csRemoveDuplicateWords(input_str):
    input_str = input_str.split()
    unique = []
    
    for word in input_str:
        if word not in unique:
            unique.append(word)
    input_str = " ".join(unique)
    
    return input_str

*********** CODE ***************
Given an integer, write a function that reverses the bits (in binary) and returns the integer result.

Examples:

csReverseIntegerBits(417) -> 267
417 in binary is 110100001. Reversing the binary is 100001011, which is 267 in decimal.
csReverseIntegerBits(267) -> 417
csReverseIntegerBits(0) -> 0

Notes:
The input integer will not be negative.
*********** CODE ***************

def csReverseIntegerBits(n):
    reversed = 0
    while(n > 0):
        reversed = reversed << 1
        if ( n & 1 == 1):
            reversed = reversed ^ 1
        n = n >> 1
    return reversed

*********** CODE ***************
Given a binary string (ASCII encoded), write a function that returns the equivalent decoded text.

Every eight bits in the binary string represents one character on the ASCII table.

Examples:
csBinaryToASCII("011011000110000101101101011000100110010001100001") -> "lambda"
01101100 -> 108 -> "l"
01100001 -> 97 -> "a"
01101101 -> 109 -> "m"
01100010 -> 98 -> "b"
01100100 -> 100 -> "d"
01100001 -> 97 -> "a"
csBinaryToASCII("") -> ""

Notes:
The input string will always be a valid binary string.
Characters can be in the range from "00000000" to "11111111" (inclusive).
In the case of an empty input string, your function should return an empty string.
*********** CODE ***************

def csBinaryToASCII(binary):
    binary_letters = []
    letters = ''
    if binary == "":
        return ""
    for index in range(0, len(binary), 8):
        binary_letters.append(binary[index : index + 8])
    for string in binary_letters:
        binary_int = v = chr(int(string, 2))
        letters += binary_int
    return letters

*********** CODE ***************
Given a number, write a function that converts that number into a string that contains "raindrop sounds" corresponding to certain potential factors. A factor is a number that evenly divides into another number, leaving no remainder. The simplest way to test if one number is a factor of another is to use the modulo operator.

Here are the rules for csRaindrop. If the input number:
has 3 as a factor, add "Pling" to the result.
has 5 as a factor, add "Plang" to the result.
has 7 as a factor, add "Plong" to the result.
does not have any of 3, 5, or 7 as a factor, the result should be the digits of the input number.

Examples:
csRaindrops(28) -> "Plong"
28 has 7 as a factor, but not 3 or 5.
csRaindrops(30) -> "PlingPlang"
30 has both 3 and 5 as factors, but not 7.
csRaindrops(34) -> "34"
34 is not factored by 3, 5, or 7.
*********** CODE ***************

def csRaindrops(number):
    output_string = ""
    has_3_factor = output_string + "Pling"
    if number % 3 == 0:
        output_string += "Pling"
    elif number % 5 == 0:
        output_string += "Plang"
    elif number % 7 == 0:
        output_string += "Plong"
    elif output_string is "":
        output_string += str(number)
    return output_string

*********** CODE ***************
You are given a non-empty array of integers.
One element appears exactly once, with every other element appearing at least twice, perhaps more.
Write a function that can find and return the element that appears exactly once

Example 1:
Input: [1,1,2,1]
Output: 2

Example 2:
Input: [1,2,1,2,1,2,80]
Output: 80
Note: You should be able to develop a solution that has O(n) time complexity.
*********** CODE ***************

from collections import defaultdict

def csFindTheSingleNumber(nums):
    hash_table = defaultdict(int)
    for i in nums:
        hash_table[i] += 1
    for i in hash_table:
        if hash_table[i] == 1:
            return i

*********** CODE ***************
Given a list of different students' scores, write a function that returns the average of each student's top five scores. You should return the averages in ascending order of the students' id numbers.
Each entry (scores[i]) has the student's id number (scores[i][0]) and the student's score (scores[i][1]). The averages should be calculated using integer division.

Example 1:

Input: [[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]
Output: [[1,87],[2,88]]
Explanation:
The average student `1` is `87`.
The average of student `2` is `88.6`, but with integer division is `88`.

*********** CODE ***************

import math

def csAverageOfTopFive(scores):
    students = {}
    answer = []
    
    for s in scores:
        if s[0] not in students:
            students[s[0]] = []
        students[s[0]].append(s[1])
    for stud in students:
        stud = students[stud].sort()    
    for stu in students:
        if len(students[stu]) > 5:
            students[stu] = students[stu][-5:]
    for st in students:
        students[st] = math.floor(sum(students[st]) / len(students[st]))
    for key, value in students.items():
        answer.append([key, value])
    return answer

*********** CODE ***************
Given a string text, you need to use the characters of text to form as many instances of the word "lambda" as possible.
You can use each character in text at most once.
Write a function that returns the maximum number of instances of "lambda" that can be formed.

Example 1:
Input: text = "mbxcdatlas"
Output: 1

Example 2:
Input: text = "lalaaxcmbdtsumbdav"
Output: 2

Example 3:
Input: text = "sctlamb"
Output: 0

Notes:
text consists of lowercase English characters only
*********** CODE ***************

def csMaxNumberOfLambdas(text):
    sub_string = "lambda"
    lambda_count = {'l': 0, 'a': 0, 'm': 0, 'b': 0, 'd': 0, 'a': 0}
    counts = []
    for letter in text:
        if letter in lambda_count:
            lambda_count[letter] += 1
    for key, value in lambda_count.items():
        counts.append(value)
    return min(counts)

*********** CODE ***************
You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.

Letters are case sensitive, so "a" is considered a different type of stone from "A".

Example 1:
Input: jewels = "aA", stones = "aAAbbbb"
Output: 3

Example 2:
Input: jewels = "z", stones = "ZZ"
Output: 0

Constraints:

1 <= jewels.length, stones.length <= 50
jewels and stones consist of only English letters.
All the characters of jewels are unique.

*********** CODE ***************

class Solution:
    Understand
    
    Input: jewels = "aA", stones = "aAAbbbb"
    Output: 3
    
    Input: jewels = "z", stones = "ZZ"
    Output: 0
    
    Plan
    Approach 1 (brute-force), O(n^2) runtime, O(1) space
    for each stone, check if that stone is IN jewels
    
        def numJewelsInStones(self, jewels: str, stones: str) -> int:
        numJewels = 0
        for stone in stones:
            if stone in jewels:
                numJewels += 1
            return numJewels
    
    Approach 2 (hash and store), O(n) runtime, O(n space)
    put jewels in set, iterate through each stone and check if stone is in jewels set
    
        def numJewelsInStones(self, jewels: str, stones: str) -> int:
        jewelSet = set(jewels)
        numJewels = 0
        for stone in stones:
            if stone in jewelSet:
                numJewels += 1
            return numJewels
    
    Approach 3 hash and store
    store each char in stone char --> numTimesOccurred
    Go through each char in jewels, get number of chars from dict
    add it all up, then you get the number of jewels
    
        def numJewelsInStones(self, jewels: str, stones: str) -> int:
        charCount = {}
        for stone in stones:
            if stone not in charCount:
                charCount[stone] = 1
            else:
                charCount[stone] += 1
        numJewels = 0
        for jewel in jewels:
            if jewel in charCount:
                numJewels += charCount[jewel]
        return numJewels
        
        --OR--
        
        charCount = defaultdict(int)
        for stone in stones:
            charCount[stone] += 1
        numJewels = 0
        for jewel in jewels:
            if jewel in charCount:
                numJewels += charCount[jewel]
        return numJewels
        
*********** CODE ***************
Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].

Return the answer in an array.

 

Example 1:

Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).
Example 2:

Input: nums = [6,5,4,8]
Output: [2,1,0,3]
Example 3:

Input: nums = [7,7,7,7]
Output: [0,0,0,0]
 

Constraints:

2 <= nums.length <= 500
0 <= nums[i] <= 100
*********** CODE ***************

class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        sortedNums = sorted(nums)
        numMap = {} 
        for (i, num) in enumerate(sortedNums):
            if num not in numMap:
                numMap[num] = i
        res = []
        for num in nums:
            res.append(numMap[num])
        return res

*********** CODE ***************
Given two strings a and b, determine if they are isomorphic.

Two strings are isomorphic if the characters in a can be replaced to get b.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

Example 1:

Input: 
a = "odd"
b = "egg"

Output:
true
Example 2:

*********** CODE ***************
def csIsomorphicStrings(a, b):
    dict_a = {}
    dict_b = {}
    
    for i, value in enumerate(a):
        dict_a[value] = dict_a.get(value, []) + [i]
            
    for j, value in enumerate(b):
        dict_b[value] = dict_b.get(value, []) + [j]
    
    if sorted(dict_a.values()) == sorted(dict_b.values()):
        return True
    else:
        return False

*********** CODE ***************
Given a pattern and a string a, find if a follows the same pattern.

Here, to "follow" means a full match, such that there is a one-to-one correspondence between a letter in pattern and a non-empty word in a.

Example 1:
Input:
pattern = "abba"
a = "lambda school school lambda"
Output: true

Example 2:
Input:
pattern = "abba"
a = "lambda school school coding"
Output:
false
*********** CODE ***************

def csWordPattern(pattern, a):
    dict_1 = {}
    dict_2 = {}
    words = a.split(' ')
    if len(words) != len(pattern):
        return False
    for (word, ch) in zip(words, pattern):
        if word not in dict_1 and ch not in dict_2:
            dict_1[word] = ch
            dict_2[ch] = word
        elif dict_1.get(word) == ch and dict_2.get(ch) == word:
            pass
        else:
            return False
    return True

*********** CODE ***************
Given an array of strings strs, write a function that can group the anagrams. The groups should be ordered such that the larger groups come first, with subsequent groups ordered in descending order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

Example 1:
Input:
strs = ["apt","pat","ear","tap","are","arm"]
Output:
[["apt","pat","tap"],["ear","are"],["arm"]]

Example 2:
Input:
strs = [""]
Output:
[[""]]

Example 3:
Input:
strs = ["a"]
Output:
[["a"]]

Notes:
strs[i] consists of lower-case English letters.
*********** CODE ***************

def csGroupAnagrams(strs):
    anagrams = {}
    for word in strs:
        sortedWord = "".join(sorted(word))
        if sortedWord in anagrams:
            anagrams[sortedWord].append(word)
        else:
            anagrams[sortedWord] = [word]
    return list(anagrams.values())

*********** CODE ***************
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.

Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
*********** CODE ***************

def search(self, nums: List[int], target: int) -> int:
    return self.searchHelper(nums, 0, len(nums) - 1, target)

def searchHelper(self, nums, min, max, target):
    if min > max:
        return -1
    mid = (min + max) // 2
    if nums[mid] == target:
        return mid
    elif nums[mid] < target:
        return self.searchHelper(nums, min, mid + 1, max, target)
    else:
        return self.searchHelper(nums, min, mid -1, target)
     
   *******************************

def iterativeSearch(self, nums: List[int], target: int) -> int:
    min, max = 0, len(nums) - 1
    while min <= max:
        mid = (min + max) // 2
        if nums[mid] == target:
            return mid
        elif nums[min] < target:
            min = mid + 1
        else:
            max = mid - 1
    return -1

*********** CODE ***************
We are playing the Guess Game. The game is as follows:
I pick a number from 1 to n. You have to guess which number I picked.
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.
You call a pre-defined API int guess(int num), which returns 3 possible results:

-1: The number I picked is lower than your guess (i.e. pick < num).
1: The number I picked is higher than your guess (i.e. pick > num).
0: The number I picked is equal to your guess (i.e. pick == num).
Return the number that I picked.

Example 1:
Input: n = 10, pick = 6
Output: 6

Example 2:
Input: n = 1, pick = 1
Output: 1
*********** CODE ***************
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -> int:

def guessNumber(self, n: int) -> int:
    min, max = 1, n
    while min <= max:
        mid = (min + max) // 2
        res = guess(mid)
        if res == 0:
            return mid
        elif res == -1:
            max = mid - 1
        else:
            min = mid + 1
    return -1

*********** CODE ***************
The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

Example 1:
Input: n = 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.

Example 2:
Input: n = 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.
*********** CODE ***************

# Memoizing = remember the old values you've computed so you don't recompute them again
    def fib(self, n: int) -> int:
        computedValues = {}
        return self.memoizedFib(n, computedValues):
        
    def memoizedFib(self, n, computedValues):
        if n in computedValues:
            return computedValues[n]
        computedValues[n] = self.memoizedFib(n - 1, computedValues) + self.memoizedFib(n - 2, computedValues)
        return computedValues[n]
    
    def dumbFib(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        return self.fib(n - 1) + self.fib(n - 2)

*********** CODE ***************
For a given positive integer n determine if it can be represented as a sum of two Fibonacci numbers (possibly equal).

Example
For n = 1, the output should be
fibonacciSimpleSum2(n) = true.

Explanation: 1 = 0 + 1 = F0 + F1.

For n = 11, the output should be
fibonacciSimpleSum2(n) = true.

Explanation: 11 = 3 + 8 = F4 + F6.
*********** CODE ***************



*********** CODE ***************
Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search for target in nums. If target exists, then return its index, otherwise, return -1.

Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1

Note:
All elements in nums are unique.
The length of nums will be <= 100
The value of each element in nums will be in the range [1, 10000]
*********** CODE ***************

def csBinarySearch(nums, target):
    min, max = 0, len(nums) - 1
    while min <= max:
        mid = (min + max) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            min = mid + 1
        else:
            max = mid - 1
    return -1

*********** CODE ***************
Given an integer array nums sorted in ascending order, and an integer target.
Suppose that nums is rotated at some pivot unknown to you beforehand (i.e., [1,2,3,4,5,6,7] might become [4,5,6,7,1,2,3]).
You should search for target in nums and if found return its index, otherwise return -1.

Example 1:
Input: nums = [6,7,1,2,3,4,5], target = 1
Output: 2

Example 2:
Input: nums = [6,7,1,2,3,4,5], target = 3
Output: 4
*********** CODE ***************

def csSearchRotatedSortedArray(nums, target):
    for i in range(len(nums)):
        if nums[i] == target:
            return i
    return -1

*********** CODE ***************
Two words are blanagrams if they are anagrams but exactly one letter has been substituted for another.
Given two words, check if they are blanagrams of each other.

Example
For word1 = "tangram" and word2 = "anagram", the output should be
checkBlanagrams(word1, word2) = true;
After changing the first letter 't' to 'a' in the word1, the words become anagrams.
*********** CODE ***************

from collections import Counter

def checkBlanagrams(word1, word2):
    ct1, ct2 = Counter(word1), Counter(word2)
    return sum((ct1 - ct2).values()) == 1 and sum((ct2 - ct1).values()) == 1

*********** CODE ***************
You are given a sorted array in ascending order that is rotated at some unknown pivot (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]) and a target value.
Write a function that returns the target value's index. If the target value is not present in the array, return -1.
You may assume no duplicate exists in the array.
Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Example 2:
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
*********** CODE ***************

def findValueSortedShiftedArray(nums, target):
    for i in range(len(nums)):
        if nums[i] == target:
            return i
    return -1

*********** CODE ***************
Note: Your solution should have O(n) time complexity, where n is the number of elements in l, since this is what you will be asked to accomplish in an interview.
You have a singly linked list l, which is sorted in strictly increasing order, and an integer value. Add value to the list l, preserving its original sorting.
Note: in examples below and tests preview linked lists are presented as arrays just for simplicity of visualization: in real data you will be given a head node l of the linked list

Example
For l = [1, 3, 4, 6] and value = 5, the output should be
insertValueIntoSortedLinkedList(l, value) = [1, 3, 4, 5, 6];
For l = [1, 3, 4, 6] and value = 10, the output should be
insertValueIntoSortedLinkedList(l, value) = [1, 3, 4, 6, 10];
For l = [1, 3, 4, 6] and value = 0, the output should be
insertValueIntoSortedLinkedList(l, value) = [0, 1, 3, 4, 6].

Input/Output
[execution time limit] 4 seconds (py3)
[input] linkedlist.integer l
A singly linked list of integers sorted in strictly increasing order. Thus, all integers in the list are pairwise distinct.
*********** CODE ***************

# Singly-linked lists are already defined with this interface:
# class ListNode(object):
#   def __init__(self, x):
#     self.value = x
#     self.next = None
#
def insertValueIntoSortedLinkedList(l, value):
    new_node = ListNode(value)
    
    if l == None or l.value > new_node.value:
        new_node.next = l
        return new_node
    prev = l
    curr = l.next
    while curr is not None:
        if curr.value > new_node.value:
            prev.next = new_node
            new_node.next = curr
            return l
        prev = curr 
        curr = curr.next
    prev.next = new_node
    return l

*********** CODE ***************
Note: Your solution should have O(l1.length + l2.length) time complexity, since this is what you will be asked to accomplish in an interview.
Given two singly linked lists sorted in non-decreasing order, your task is to merge them. In other words, return a singly linked list, also sorted in non-decreasing order, that contains the elements from both original lists.

Example
For l1 = [1, 2, 3] and l2 = [4, 5, 6], the output should be
mergeTwoLinkedLists(l1, l2) = [1, 2, 3, 4, 5, 6];
For l1 = [1, 1, 2, 4] and l2 = [0, 3, 5], the output should be
mergeTwoLinkedLists(l1, l2) = [0, 1, 1, 2, 3, 4, 5].
*********** CODE ***************

# Singly-linked lists are already defined with this interface:
# class ListNode(object):
#   def __init__(self, x):
#     self.value = x
#     self.next = None
#
def mergeTwoLinkedLists(l1, l2):
    currentNode = l1 if l1 != None else l2
    listNumber = 1 if l1 != None else 2
    output = []
    while currentNode is not None:
        output.append(currentNode.value)
        if currentNode.next == None:
            if listNumber == 1:
                listNumber = 2
                currentNode = l2
            else:
                currentNode = None
        else:
            currentNode = currentNode.next
    return sorted(output)

*********** CODE ***************
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the MinStack class:
MinStack() initializes the stack object.
void push(val) pushes the element val onto the stack.
void pop() removes the element on the top of the stack.
int top() gets the top element of the stack.
int getMin() retrieves the minimum element in the stack.

Example 1:

Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
*********** CODE ***************

from collections import deque

class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = deque()
        self.minVal = float("inf")

    def push(self, val: int) -> None:
        if val < self.minVal:
            self.minVal = val
        self.stack.append(val)

    def pop(self) -> None:
        val = self.stack.pop()
        if val == self.minVal:
            if len(self.stack) > 0:
                self.minVal = min(self.stack)
            else:
                self.minVal = float("inf")

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minVal


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()

*********** CODE ***************
Implement a last in first out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal queue (push, top, pop, and empty).

Implement the MyStack class:
void push(int x) Pushes element x to the top of the stack.
int pop() Removes the element on the top of the stack and returns it.
int top() Returns the element on the top of the stack.
boolean empty() Returns true if the stack is empty, false otherwise.

Notes:
You must use only standard operations of a queue, which means only push to back, peek/pop from front, size, and is empty operations are valid.
Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue), as long as you use only a queue's standard operations.
*********** CODE ***************

from collections import deque

class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = deque()

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.queue.append(x)

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        if len(self.queue) == 0:
            return float("inf")
        
        temp = deque()
        while len(self.queue) > 1:
            temp.append(self.queue.popleft())
            
        lastElement = self.queue.popleft()
        self.queue = temp
        return lastElement

    def top(self) -> int:
        """
        Get the top element.
        """
        if len(self.queue) == 0:
            return float("inf")
        
        temp = deque()
        while len(self.queue) > 1:
            temp.append(self.queue.popleft())
            
        lastElement = self.queue.popleft()
        temp.append(lastElement)
        self.queue = temp
        return lastElement

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return len(self.queue) == 0

*********** CODE ***************
Implement a queue using two stacks.

You are given an array of requests, where requests[i] can be "push <x>" or "pop". Return an array composed of the results of each "pop" operation that is performed.

Example

For requests = ["push 1", "push 2", "pop", "push 3", "pop"], the output should be
queueOnStacks(requests) = [1, 2].

After the first request, the queue is {1}; after the second it is {1, 2}. Then we do the third request, "pop", and add the first element of the queue 1 to the answer array. The queue becomes {2}. After the fourth request, the queue is {2, 3}. Then we perform "pop" again and add 2 to the answer array, and the queue becomes {3}.
*********** CODE ***************

class Stack:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

def queueOnStacks(requests):
    left = Stack()
    right = Stack()

    def insert(x):
        left.push(x)

    def remove():
        while not left.isEmpty():
            ele = left.pop()
            right.push(ele)
        item = right.pop()
        
        while not right.isEmpty():
            element = right.pop()
            left.push(element)
        return item
        
    ans = []
    for request in requests:
        req = request.split(" ")
        if req[0] == 'push':
            insert(int(req[1]))
        else:
            ans.append(remove())
    return ans

*********** CODE ***************
Given a string sequence consisting of the characters '(', ')', '[', ']', '{', and '}'. Your task is to determine whether or not the sequence is a valid bracket sequence.
The Valid bracket sequence is defined in the following way:
An empty bracket sequence is a valid bracket sequence.
If S is a valid bracket sequence then (S), [S] and {S} are also valid.
If A and B are valid bracket sequences then AB is also valid.

Example
For sequence = "()", the output should be validBracketSequence(sequence) = true;
For sequence = "()[]{}", the output should be validBracketSequence(sequence) = true;
For sequence = "(]", the output should be validBracketSequence(sequence) = false;
For sequence = "([)]", the output should be validBracketSequence(sequence) = false;
For sequence = "{[]}", the output should be validBracketSequence(sequence) = true.
*********** CODE ***************

def validBracketSequence(sequence):
    openList = ["(", "[", "{"]
    closedList = [")", "]", "}"]
    newList = []
    
    for i in sequence:
        if i in openList:
            newList.append(i)
        elif i in closedList:
            pos = closedList.index(i)
            if ((len(newList) > 0) and 
                (openList[pos] == newList[len(newList) - 1])):
                newList.pop()
            else:
                return False
    if len(newList) == 0:
        return True
    else:
        return False 

*********** CODE ***************
You are given a binary tree and you need to write a function that can determine if it is height-balanced.
A height-balanced tree can be defined as a binary tree in which the left and right subtrees of every node differ in height by a maximum of 1.

Example 1:
Given the following tree [5,10,25,None,None,12,3]:

    5
   / \
 10  25
    /  \
   12   3
return True.
*********** CODE ***************

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def balancedBinaryTree(root):
    if root is None:
        return True
        
    lh = height(root.left)
    rh = height(root.right)
    if (abs(lh - rh) <= 1) and balancedBinaryTree(root.left) is True and balancedBinaryTree(root.right) is True:
        return True
    return False

def height(root):
    if root is None:
        return 0
    return max(height(root.left), height(root.right)) + 1

*********** CODE ***************
You are given a binary tree and you are asked to write a function that finds its minimum depth. The minimum depth can be defined as the number of nodes along the shortest path from the root down to the nearest leaf node. As a reminder, a leaf node is a node with no children.

Example:
Given the binary tree [5,7,22,None,None,17,9],

    5
   / \
  7  22
    /  \
   17   9
your function should return its minimum depth = 2.
*********** CODE ***************

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def minimumDepthBinaryTree(root):
    if root is None:
        return 0
        
    if root.left is None and root.right is None: 
        return 1
        
    if root.left is None: 
        return minimumDepthBinaryTree(root.right) + 1
        
    if root.right is None: 
        return minimumDepthBinaryTree(root.left) + 1     
    return min(minimumDepthBinaryTree(root.left), minimumDepthBinaryTree(root.right)) + 1

*********** CODE ***************
You are given a binary tree. Write a function that returns the binary tree's node values using an in-order traversal.

Example:
Input: [2,None,3,4]

   2
    \
     3
    /
   4
*********** CODE ***************

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def binaryTreeInOrderTraversal(root):
    res = []
    if root:
        res = binaryTreeInOrderTraversal(root.left)
        res.append(root.value)
        res = res + binaryTreeInOrderTraversal(root.right)
    return res

*********** CODE ***************
Note: Try to solve this task without using recursion, since this is what you'll be asked to do during an interview.

Given a binary tree of integers t, return its node values in the following format:

The first element should be the value of the tree root;
The next elements should be the values of the nodes at height 1 (i.e. the root children), ordered from the leftmost to the rightmost one;
The elements after that should be the values of the nodes at height 2 (i.e. the children of the nodes at height 1) ordered in the same way;
Etc.

Example
For
t = {
    "value": 1,
    "left": {
        "value": 2,
        "left": null,
        "right": {
            "value": 3,
            "left": null,
            "right": null
        }
    },
    "right": {
        "value": 4,
        "left": {
            "value": 5,
            "left": null,
            "right": null
        },
        "right": null
    }
}
the output should be
traverseTree(t) = [1, 2, 4, 3, 5].

This t looks like this:

     1
   /   \
  2     4
   \   /
    3 5
*********** CODE ***************

from collections import deque

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def traverseTree(t):
    if t == None:
        return []
        
    q = deque()
    q.append(t)
    res = []
    
    while len(q) > 0:
        curr = q.popleft()
        res.append(curr.value)
        if curr.left != None:
            q.append(curr.left)
        if curr.right != None:
            q.append(curr.right)
    return res

*********** CODE ***************
Given a binary tree of integers, return all the paths from the tree's root to its leaves as an array of strings. The strings should have the following format:
"root->node1->node2->...->noden", representing the path from root to noden, where root is the value stored in the root and node1,node2,...,noden are the values stored in the 1st, 2nd,..., and nth nodes in the path respectively (noden representing the leaf).

Example
For
t = {
    "value": 5,
    "left": {
        "value": 2,
        "left": {
            "value": 10,
            "left": null,
            "right": null
        },
        "right": {
            "value": 4,
            "left": null,
            "right": null
        }
    },
    "right": {
        "value": -3,
        "left": null,
        "right": null
    }
}
the output should be
treePaths(t) = ["5->2->10", "5->2->4", "5->-3"].

The given tree looks like this:

    5
   / \
  2  -3
 / \
10  4
*********** CODE ***************

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def treePaths(t):
    if t == None:
        return []
        
    res = []
    currPath = ""
    treeHelper(t, res, currPath)
    return res
    
def treeHelper(root, res, currPath):
    currPath += f"{root.value}"
    if root.left == None and root.right == None:
        res.append(currPath)
        return
    if root.left != None:
        newPath = currPath + "->"
        treeHelper(root.left, res, newPath)
    if root.right != None:
        newPath = currPath + "->"
        treeHelper(root.right, res, newPath)

*********** CODE ***************
Note: Your solution should have O(l.length) time complexity and O(1) space complexity, since this is what you will be asked to accomplish in an interview.

Given a singly linked list, reverse and return it.

Example
For l = [1, 2, 3, 4, 5], the output should be
reverseLinkedList(l) = [5, 4, 3, 2, 1].

*********** CODE ***************

# Singly-linked lists are already defined with this interface:
# class ListNode(object):
#   def __init__(self, x):
#     self.value = x
#     self.next = None
#
def reverseLinkedList(l):
    prev_node = None
    curr_node = l
    while curr_node:
        next_node = curr_node.next 
        curr_node.next = prev_node  
        prev_node = curr_node  
        curr_node = next_node  
    l = prev_node
    return l

*********** CODE ***************
You are given the root node of a binary search tree (BST).
You need to write a function that returns the sum of values of all the nodes with a value between lower and upper (inclusive).
The BST is guaranteed to have unique values.

Example 1:
Input:
root = [10, 5, 15, 3, 7, null, 18]
lower = 7
upper = 15

         10
         / \
        5  15
       / \    \
      3   7    18

Output:
32
*********** CODE ***************

def csBSTRangeSum(root, lower, upper):
    l = []
    
    def inOrder(root):
        if not root:
            return
        inOrder(root.left)
        if lower <= root.value <= upper:
            l.append(root.value)
        inOrder(root.right)
        
    inOrder(root)
    return sum(l)

*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

