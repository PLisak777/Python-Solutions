Write a function that searches a list of names (unsorted) for the name "Bob" and returns the location in the list. If Bob is not in the array, return -1.

Examples:

csWhereIsBob(["Jimmy", "Layla", "Bob"]) ➞ 2
csWhereIsBob(["Bob", "Layla", "Kaitlyn", "Patricia"]) ➞ 0
csWhereIsBob(["Jimmy", "Layla", "James"]) ➞ -1
Notes:

Assume all names start with a capital letter and are lowercase thereafter (i.e. don't worry about finding "BOB" or "bob").

********** CODE ************

def csWhereIsBob(names):
    bob = "Bob"
    if bob in names:
        return names.index(bob)
    else:
        return -1
        
*********** CODE ***************

Create a function that returns True if the given string has any of the following:

Only letters and no numbers.
Only numbers and no letters.
If a string has both numbers and letters or contains characters that don't fit into any category, return False.

Examples:

csAlphanumericRestriction("Bold") ➞ True
csAlphanumericRestriction("123454321") ➞ True
csAlphanumericRestriction("H3LL0") ➞ False
Notes:

Any string that contains spaces or is empty should return False.

*********** CODE ***************

def csAlphanumericRestriction(input_str):
    if input_str.isalpha() or input_str.isdigit():
        return True
    else:
        return False

*********** CODE ***************

Write a function that takes a string as input and returns that string in reverse order, with the opposite casing for each character within the string.

Examples:

csOppositeReverse("Hello World") ➞ "DLROw OLLEh"
csOppositeReverse("ReVeRsE") ➞ "eSrEvEr"
csOppositeReverse("Radar") ➞ "RADAr"
Notes:

The input string will only contain alpha characters.

*********** CODE ***************

def csOppositeReverse(txt):
    a = txt[::-1]
    return a.swapcase()

*********** CODE ***************

Create a function that given an integer, returns an integer where every digit in the input integer is squared.

Examples:

csSquareAllDigits(9119) -> 811181 because 9^2 = 81, 1^2 = 1, 1^2 = 1, and 9^2 = 81
csSquareAllDigits(2483) -> 416649 because 2^2 = 4, 4^2 = 16, 8^2 = 64, and 3^2 = 9

*********** CODE ***************

def csSquareAllDigits(n):
    res = ""
    for ch in str(n):
        res = res + str(int(ch)**2)
    return int(res)

*********** CODE ***************

Imagine a school that children attend for years. In each year, there are a certain number of groups started, marked with the letters. So if years = 7 and groups = 4For the first year, the groups are 1a, 1b, 1c, 1d, and for the last year, the groups are 7a, 7b, 7c, 7d.

Write a function that returns the groups in the school by year (as a string), separated with a comma and space in the form of "1a, 1b, 1c, 1d, 2a, 2b (....) 6d, 7a, 7b, 7c, 7d".

Examples:

csSchoolYearsAndGroups(years = 7, groups = 4) ➞ "1a, 1b, 1c, 1d, 2a, 2b, 2c, 2d, 3a, 3b, 3c, 3d, 4a, 4b, 4c, 4d, 5a, 5b, 5c, 5d, 6a, 6b, 6c, 6d, 7a, 7b, 7c, 7d"
Notes:

1 <= years <= 10
1 <= groups <=26

*********** CODE ***************

def csSchoolYearsAndGroups(years, groups):
    my_list = []
    for x in range(years):
        x += 1
        x_iteration = str(x)
        letter = ord("a")
        for y in range(groups):
            y += 1
            y_iteration = chr(letter)
            xy_iteration = x_iteration + y_iteration
            my_list.append(xy_iteration)
            letter += 1
    return ", ".join(map(str, my_list))

*********** CODE ***************

Create a function that concatenates the number 7 to the end of every chord in a list. If a chord already ends with a 7, do not add another 7.

Examples:

csMakeItJazzy(["G", "F", "C"]) ➞ ["G7", "F7", "C7"]
csMakeItJazzy(["G", "F7", "C"]) ➞ ["G7", "F7", "C7"]
csMakeItJazzy(["Dm", "G", "E", "A"]) ➞ ["Dm7", "G7", "E7", "A7"]
csMakeItJazzy(["F7", "E7", "A7", "Ab7", "Gm7", "C7"]) ➞ ["F7", "E7", "A7", "Ab7", "Gm7", "C7"]
csMakeItJazzy([]) ➞ []
Notes:

Return an empty list if the given list is empty.
You can expect all the tests to have valid chords.

*********** CODE ***************

def csMakeItJazzy(chords):
    if not chords:
        return chords
    else:
      i = 0
      for chord in chords:
        last = chord[-1]
        if ord(last) == 55:
          pass
        else:
            new_chord = chord + str(7)
            chords[i] = new_chord
        i += 1
    return(chords)

*********** CODE ***************

Given a string, return a new string with all the vowels removed.

Examples:

csRemoveTheVowels("Lambda School is awesome!") -> "Lmbd Schl s wsm!"
Notes:

For this challenge, "y" is not considered a vowel.
[execution time limit] 4 seconds (py3)

[input] string input_str

[output] string

[Python 3] Syntax Tips

# Prints help message to the console
# Returns a string
def helloWorld(name):
    print "This prints to the console when you Run Tests"
    return "Hello, " + name

*********** CODE ***************

def csRemoveTheVowels(input_str):
    vowels = ("A", "a", "E", "e", "I", "i", "O", "o", "U", "u")
    for x in input_str:
        if x in vowels:
            input_str = input_str.replace(x, "")
    return input_str

*********** CODE ***************

Given a start integer and an ending integer (both inclusive), write a function that returns the count (not the sum) of all integers in the range (except integers that contain the digit 5).

Examples:

csAnythingButFive(1, 5) -> 1, 2, 3, 4, -> 4 (there are 4 integers in the range that do not contain the digit 5)
csAnythingButFive(1, 9) -> 1, 2, 3, 4, 6, 7, 8, 9 -> 8
csAnythingButFive(4, 17) -> 4,6,7,8,9,10,11,12,13,14,16,17 -> 12
Notes:

The output can contain the digit 5.
The start number will always be less than the end number (both numbers can also be negative).

*********** CODE ***************

def csAnythingButFive(start, end):
    x = range(start, end + 1)
    counter = 0
    for i in x:
        if "5" not in str(i):
            counter += 1
    return counter

*********** CODE ***************

Given an array of integers, return the sum of all the positive integers in the array.

Examples:

csSumOfPositive([1, 2, 3, -4, 5]) -> 1 + 2 + 3 + 5 = 11
csSumOfPositive([-3, -2, -1, 0, 1]) -> 1
csSumOfPositive([-3, -2]) -> 0
Notes:

If the input_arr does not contain any positive integers, the default sum should be 0.

*********** CODE ***************

def csSumOfPositive(input_arr):
    runningTotal = 0
    for x in input_arr:
        if x > 0:
            runningTotal = runningTotal + x
    return runningTotal

*********** CODE ***************

Given a string of words, return the length of the shortest word(s).

Notes:

The input string will never be empty and you do not need to validate for different data types.

*********** CODE ***************

def csShortestWord(input_str):
    x = list(map(len, input_str.split()))
    return min(x)

*********** CODE ***************

Given a sorted array (in ascending order) of integers and a target, write a function that finds the two integers that add up to the target.

Examples:

csSortedTwoSum([3,8,12,16], 11) -> [0,1]
csSortedTwoSum([3,4,5], 8) -> [0,2]
csSortedTwoSum([0,1], 1) -> [0,1]
Notes:

Each input will have exactly one solution.
You may not use the same element twice.

*********** CODE ***************

def csSortedTwoSum(numbers, target):
    for i in range(len(numbers) - 1):
        for j in range(i + 1, len(numbers)):
            if numbers[i] + numbers[j] == target:
                return [i, j]

*********** CODE ***************

You are given two strings, str_1 and str_2, where str_2 is generated by randomly shuffling str_1 and then adding one letter at a random position.

Write a function that returns the letter that was added to str_2.

Examples:

csFindAddedLetter(str_1 = "bcde", str_2 = "bcdef") -> "f"
csFindAddedLetter(str_1 = "", str_2 = "z") -> "z"
csFindAddedLetter(str_1 = "b", str_2 = "bb") -> "b"
csFindAddedLetter(str_1 = "bf", str_2 = "bfb") -> "b"
Notes:

str_1 and str_2 both consist of only lowercase alpha characters.

*********** CODE ***************

def csFindAddedLetter(str_1, str_2):
    i = list(str_1)
    j = list(str_2)
    
    j.sort()
    for x in i:
        j.remove(x)
    return "".join(j)

*********** CODE ***************

Given a string, write a function that returns the index of the first unique (non-repeating) character. If there isn't a unique (non-repeating) character, return -1.

Examples:

csFirstUniqueChar(input_str = "lambdaschool") -> 2
csFirstUniqueChar(input_str = "ilovelambdaschool") -> 0
csFirstUniqueChar(input_str = "vvv") -> -1
Notes:

input_str will only contain lowercase alpha characters.

*********** CODE ***************

def csFirstUniqueChar(input_str):
    orig = list(input_str)
    seen = []
    
    for i, j in enumerate(input_str):
        orig = orig[1:]
        if j not in orig and j not in seen:
            return i
        seen.append(input_str[i])
    return -1

*********** CODE ***************

Given two strings that include only lowercase alpha characters, str_1 and str_2, write a function that returns a new sorted string that contains any character (only once) that appeared in str_1 or str_2.

Examples:

csLongestPossible("aabbbcccdef", "xxyyzzz") -> "abcdefxyz"
csLongestPossible("abc", "abc") -> "abc"

*********** CODE ***************

def csLongestPossible(str_1, str_2):
    new_str = []
    for i in str_1:
        if i not in new_str:
            new_str.append(i)
    for j in str_2:
        if j not in new_str:
            new_str.append(j)
    new_str.sort()
    listToString = "".join(map(str, new_str))
    return listToString

*********** CODE ***************

You are given the prices of a stock, in the form of an array of integers, prices. Let's say that prices[i] is the price of the stock on the ith day (0-based index). Assuming that you are allowed to buy and sell the stock only once, your task is to find the maximum possible profit (the difference between the buy and sell prices).

Note: You can assume there are no fees associated with buying or selling the stock.

Example

For prices = [6, 3, 1, 2, 5, 4], the output should be buyAndSellStock(prices) = 4.

It would be most profitable to buy the stock on day 2 and sell it on day 4. Thus, the maximum profit is prices[4] - prices[2] = 5 - 1 = 4.

For prices = [8, 5, 3, 1], the output should be buyAndSellStock(prices) = 0.

Since the value of the stock drops each day, there's no way to make a profit from selling it. Hence, the maximum profit is 0.

For prices = [3, 100, 1, 97], the output should be buyAndSellStock(prices) = 97.

It would be most profitable to buy the stock on day 0 and sell it on day 1. Thus, the maximum profit is prices[1] - prices[0] = 100 - 3 = 97.

*********** CODE ***************

def buyAndSellStock(prices):
    minSell = 0
    maxSell = 1
    minBuy = 0
    maxProfit = 0
    
    if len(prices) > 2:    
        for i, j in enumerate(prices):
            if (prices[i] < prices[minBuy]):
                minBuy = i
            if (prices[maxSell] - prices[minSell] < prices[i] - prices[minBuy]):
                maxSell = i
                minSell = minBuy
        
        maxProfit = prices[maxSell] - prices[minSell]
    return maxProfit

*********** CODE ***************

Given a string, your task is to replace each of its characters by the next one in the English alphabet; i.e. replace a with b, replace b with c, etc (z would be replaced by a).

Example

For inputString = "crazy", the output should be alphabeticShift(inputString) = "dsbaz".

*********** CODE ***************

def alphabeticShift(inputString):
    a=ord('a')
    alph=[chr(i) for i in range(a, a+26)]
    str_list = list(inputString)
    new_arr = []
    
    for l in str_list:
        if l in alph and l != "z":
            inx = alph.index(l, 0, 27)
            nextLetter = alph[inx + 1]
            new_arr.append(nextLetter)
        else:
            new_arr.append(alph[0])
        answer = "".join(new_arr)
    return answer

*********** CODE ***************

You are given a parentheses sequence, check if it's regular.

Example

For s = "()()(())", the output should be
validParenthesesSequence(s) = true;
For s = "()()())", the output should be
validParenthesesSequence(s) = false.

*********** CODE ***************

def validParenthesesSequence(s):
    openList = ["("]
    closedList = [")"]
    newList = []
    
    for i in s:
        if i in openList:
            newList.append(i)
        elif i in closedList:
            pos = closedList.index(i)
            if ((len(newList) > 0) and 
                (openList[pos] == newList[len(newList) - 1])):
                newList.pop()
            else:
                return False
    if len(newList) == 0:
        return True
    else:
        return False  

*********** CODE ***************

Given a string (the input will be in the form of an array of characters), write a function that returns the reverse of the given string.

Examples:

csReverseString(["l", "a", "m", "b", "d", "a"]) -> ["a", "d", "b", "m", "a", "l"]
csReverseString(["I", "'", "m", " ", "a", "w", "e", "s", "o", "m", "e"]) -> ["e", "m", "o", "s", "e", "w", "a", " ", "m", "'", "I"]

*********** CODE ***************

def csReverseString(chars):
    reversedString = chars[::-1]
    return reversedString

*********** CODE ***************

A palindrome is a word, phrase, number, or another sequence of characters that reads the same backward or forward. This includes capital letters, punctuation, and other special characters.

Given a string, write a function that checks if the input is a valid palindrome.

Examples:

csCheckPalindrome("racecar") -> true
csCheckPalindrome("anna") -> true
csCheckPalindrome("12345") -> false
csCheckPalindrome("12321") -> true

*********** CODE ***************

def csCheckPalindrome(input_str):
    return input_str == input_str[::-1]
    
            ***OR***
            
def csCheckPalindrome(input_str):
    firstChar = 0
    lastChar = len(input_str) - 1
    isPalindrome = True
    for i in range(len(input_str)) :
        firstChar = firstPos(input_str, firstChar, lastChar);
        lastChar = lastPos(input_str, lastChar, firstChar);
        if (lastChar < 0 or firstChar < 0):
            break
        if (input_str[firstChar] == input_str[lastChar]):
            firstChar += 1
            lastChar -= 1
            continue
        isPalindrome = False
        break  
    return isPalindrome
    
# Helper function to get the position of first character in the string
def firstPos(input_str, start, end):
    firstChar = -1
    for i in range(start, end + 1):
        if (input_str[i] >= 'a' and input_str[i] <= 'z') :
            firstChar = i
            break  
    return firstChar

# Helper function to get the position of last character in the string
def lastPos(input_str, start, end):  
    lastChar = -1  
    for i in range(start, end - 1, -1) :
        if (input_str[i] >= 'a' and input_str[i] <= 'z') :
            lastChar = i
            break  
    return lastChar

*********** CODE ***************

Given a string, write a function that removes all duplicate words from the input. The string that you return should only contain the first occurrence of each word in the string.

Examples:

`csRemoveDuplicateWords("alpha bravo bravo golf golf golf delta alpha bravo bravo golf golf golf delta") -> "alpha bravo golf delta"
`csRemoveDuplicateWords("my dog is my dog is super smart") -> "my dog is super smart"

*********** CODE ***************

def csRemoveDuplicateWords(input_str):
    input_str = input_str.split()
    unique = []
    
    for word in input_str:
        if word not in unique:
            unique.append(word)
    input_str = " ".join(unique)
    
    return input_str

*********** CODE ***************
Given an integer, write a function that reverses the bits (in binary) and returns the integer result.

Examples:

csReverseIntegerBits(417) -> 267
417 in binary is 110100001. Reversing the binary is 100001011, which is 267 in decimal.
csReverseIntegerBits(267) -> 417
csReverseIntegerBits(0) -> 0

Notes:
The input integer will not be negative.
*********** CODE ***************

def csReverseIntegerBits(n):
    reversed = 0
    while(n > 0):
        reversed = reversed << 1
        if ( n & 1 == 1):
            reversed = reversed ^ 1
        n = n >> 1
    return reversed

*********** CODE ***************
Given a binary string (ASCII encoded), write a function that returns the equivalent decoded text.

Every eight bits in the binary string represents one character on the ASCII table.

Examples:
csBinaryToASCII("011011000110000101101101011000100110010001100001") -> "lambda"
01101100 -> 108 -> "l"
01100001 -> 97 -> "a"
01101101 -> 109 -> "m"
01100010 -> 98 -> "b"
01100100 -> 100 -> "d"
01100001 -> 97 -> "a"
csBinaryToASCII("") -> ""

Notes:
The input string will always be a valid binary string.
Characters can be in the range from "00000000" to "11111111" (inclusive).
In the case of an empty input string, your function should return an empty string.
*********** CODE ***************

def csBinaryToASCII(binary):
    binary_letters = []
    letters = ''
    if binary == "":
        return ""
    for index in range(0, len(binary), 8):
        binary_letters.append(binary[index : index + 8])
    for string in binary_letters:
        binary_int = v = chr(int(string, 2))
        letters += binary_int
    return letters

*********** CODE ***************
Given a number, write a function that converts that number into a string that contains "raindrop sounds" corresponding to certain potential factors. A factor is a number that evenly divides into another number, leaving no remainder. The simplest way to test if one number is a factor of another is to use the modulo operator.

Here are the rules for csRaindrop. If the input number:
has 3 as a factor, add "Pling" to the result.
has 5 as a factor, add "Plang" to the result.
has 7 as a factor, add "Plong" to the result.
does not have any of 3, 5, or 7 as a factor, the result should be the digits of the input number.

Examples:
csRaindrops(28) -> "Plong"
28 has 7 as a factor, but not 3 or 5.
csRaindrops(30) -> "PlingPlang"
30 has both 3 and 5 as factors, but not 7.
csRaindrops(34) -> "34"
34 is not factored by 3, 5, or 7.
*********** CODE ***************

def csRaindrops(number):
    output_string = ""
    has_3_factor = output_string + "Pling"
    if number % 3 == 0:
        output_string += "Pling"
    elif number % 5 == 0:
        output_string += "Plang"
    elif number % 7 == 0:
        output_string += "Plong"
    elif output_string is "":
        output_string += str(number)
    return output_string

*********** CODE ***************
You are given a non-empty array of integers.
One element appears exactly once, with every other element appearing at least twice, perhaps more.
Write a function that can find and return the element that appears exactly once

Example 1:
Input: [1,1,2,1]
Output: 2

Example 2:
Input: [1,2,1,2,1,2,80]
Output: 80
Note: You should be able to develop a solution that has O(n) time complexity.
*********** CODE ***************

from collections import defaultdict

def csFindTheSingleNumber(nums):
    hash_table = defaultdict(int)
    for i in nums:
        hash_table[i] += 1
    for i in hash_table:
        if hash_table[i] == 1:
            return i

*********** CODE ***************
Given a list of different students' scores, write a function that returns the average of each student's top five scores. You should return the averages in ascending order of the students' id numbers.
Each entry (scores[i]) has the student's id number (scores[i][0]) and the student's score (scores[i][1]). The averages should be calculated using integer division.

Example 1:

Input: [[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]
Output: [[1,87],[2,88]]
Explanation:
The average student `1` is `87`.
The average of student `2` is `88.6`, but with integer division is `88`.

*********** CODE ***************

import math

def csAverageOfTopFive(scores):
    students = {}
    answer = []
    
    for s in scores:
        if s[0] not in students:
            students[s[0]] = []
        students[s[0]].append(s[1])
    for stud in students:
        stud = students[stud].sort()    
    for stu in students:
        if len(students[stu]) > 5:
            students[stu] = students[stu][-5:]
    for st in students:
        students[st] = math.floor(sum(students[st]) / len(students[st]))
    for key, value in students.items():
        answer.append([key, value])
    return answer

*********** CODE ***************
Given a string text, you need to use the characters of text to form as many instances of the word "lambda" as possible.
You can use each character in text at most once.
Write a function that returns the maximum number of instances of "lambda" that can be formed.

Example 1:
Input: text = "mbxcdatlas"
Output: 1

Example 2:
Input: text = "lalaaxcmbdtsumbdav"
Output: 2

Example 3:
Input: text = "sctlamb"
Output: 0

Notes:
text consists of lowercase English characters only
*********** CODE ***************

def csMaxNumberOfLambdas(text):
    sub_string = "lambda"
    lambda_count = {'l': 0, 'a': 0, 'm': 0, 'b': 0, 'd': 0, 'a': 0}
    counts = []
    for letter in text:
        if letter in lambda_count:
            lambda_count[letter] += 1
    for key, value in lambda_count.items():
        counts.append(value)
    return min(counts)

*********** CODE ***************
You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.

Letters are case sensitive, so "a" is considered a different type of stone from "A".

Example 1:
Input: jewels = "aA", stones = "aAAbbbb"
Output: 3

Example 2:
Input: jewels = "z", stones = "ZZ"
Output: 0

Constraints:

1 <= jewels.length, stones.length <= 50
jewels and stones consist of only English letters.
All the characters of jewels are unique.

*********** CODE ***************

class Solution:
    Understand
    
    Input: jewels = "aA", stones = "aAAbbbb"
    Output: 3
    
    Input: jewels = "z", stones = "ZZ"
    Output: 0
    
    Plan
    Approach 1 (brute-force), O(n^2) runtime, O(1) space
    for each stone, check if that stone is IN jewels
    
        def numJewelsInStones(self, jewels: str, stones: str) -> int:
        numJewels = 0
        for stone in stones:
            if stone in jewels:
                numJewels += 1
            return numJewels
    
    Approach 2 (hash and store), O(n) runtime, O(n space)
    put jewels in set, iterate through each stone and check if stone is in jewels set
    
        def numJewelsInStones(self, jewels: str, stones: str) -> int:
        jewelSet = set(jewels)
        numJewels = 0
        for stone in stones:
            if stone in jewelSet:
                numJewels += 1
            return numJewels
    
    Approach 3 hash and store
    store each char in stone char --> numTimesOccurred
    Go through each char in jewels, get number of chars from dict
    add it all up, then you get the number of jewels
    
        def numJewelsInStones(self, jewels: str, stones: str) -> int:
        charCount = {}
        for stone in stones:
            if stone not in charCount:
                charCount[stone] = 1
            else:
                charCount[stone] += 1
        numJewels = 0
        for jewel in jewels:
            if jewel in charCount:
                numJewels += charCount[jewel]
        return numJewels
        
        --OR--
        
        charCount = defaultdict(int)
        for stone in stones:
            charCount[stone] += 1
        numJewels = 0
        for jewel in jewels:
            if jewel in charCount:
                numJewels += charCount[jewel]
        return numJewels
        
*********** CODE ***************
Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].

Return the answer in an array.

 

Example 1:

Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).
Example 2:

Input: nums = [6,5,4,8]
Output: [2,1,0,3]
Example 3:

Input: nums = [7,7,7,7]
Output: [0,0,0,0]
 

Constraints:

2 <= nums.length <= 500
0 <= nums[i] <= 100
*********** CODE ***************

class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        sortedNums = sorted(nums)
        numMap = {} 
        for (i, num) in enumerate(sortedNums):
            if num not in numMap:
                numMap[num] = i
        res = []
        for num in nums:
            res.append(numMap[num])
        return res

*********** CODE ***************
Given two strings a and b, determine if they are isomorphic.

Two strings are isomorphic if the characters in a can be replaced to get b.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

Example 1:

Input: 
a = "odd"
b = "egg"

Output:
true
Example 2:

*********** CODE ***************
def csIsomorphicStrings(a, b):
    dict_a = {}
    dict_b = {}
    
    for i, value in enumerate(a):
        dict_a[value] = dict_a.get(value, []) + [i]
            
    for j, value in enumerate(b):
        dict_b[value] = dict_b.get(value, []) + [j]
    
    if sorted(dict_a.values()) == sorted(dict_b.values()):
        return True
    else:
        return False

*********** CODE ***************
Given a pattern and a string a, find if a follows the same pattern.

Here, to "follow" means a full match, such that there is a one-to-one correspondence between a letter in pattern and a non-empty word in a.

Example 1:
Input:
pattern = "abba"
a = "lambda school school lambda"
Output: true

Example 2:
Input:
pattern = "abba"
a = "lambda school school coding"
Output:
false
*********** CODE ***************

def csWordPattern(pattern, a):
    dict_1 = {}
    dict_2 = {}
    words = a.split(' ')
    if len(words) != len(pattern):
        return False
    for (word, ch) in zip(words, pattern):
        if word not in dict_1 and ch not in dict_2:
            dict_1[word] = ch
            dict_2[ch] = word
        elif dict_1.get(word) == ch and dict_2.get(ch) == word:
            pass
        else:
            return False
    return True

*********** CODE ***************
Given an array of strings strs, write a function that can group the anagrams. The groups should be ordered such that the larger groups come first, with subsequent groups ordered in descending order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

Example 1:
Input:
strs = ["apt","pat","ear","tap","are","arm"]
Output:
[["apt","pat","tap"],["ear","are"],["arm"]]

Example 2:
Input:
strs = [""]
Output:
[[""]]

Example 3:
Input:
strs = ["a"]
Output:
[["a"]]

Notes:
strs[i] consists of lower-case English letters.
*********** CODE ***************

def csGroupAnagrams(strs):
    anagrams = {}
    for word in strs:
        sortedWord = "".join(sorted(word))
        if sortedWord in anagrams:
            anagrams[sortedWord].append(word)
        else:
            anagrams[sortedWord] = [word]
    return list(anagrams.values())

*********** CODE ***************
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.

Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
*********** CODE ***************

def search(self, nums: List[int], target: int) -> int:
    return self.searchHelper(nums, 0, len(nums) - 1, target)

def searchHelper(self, nums, min, max, target):
    if min > max:
        return -1
    mid = (min + max) // 2
    if nums[mid] == target:
        return mid
    elif nums[mid] < target:
        return self.searchHelper(nums, min, mid + 1, max, target)
    else:
        return self.searchHelper(nums, min, mid -1, target)
     
   *******************************

def iterativeSearch(self, nums: List[int], target: int) -> int:
    min, max = 0, len(nums) - 1
    while min <= max:
        mid = (min + max) // 2
        if nums[mid] == target:
            return mid
        elif nums[min] < target:
            min = mid + 1
        else:
            max = mid - 1
    return -1

*********** CODE ***************
We are playing the Guess Game. The game is as follows:
I pick a number from 1 to n. You have to guess which number I picked.
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.
You call a pre-defined API int guess(int num), which returns 3 possible results:

-1: The number I picked is lower than your guess (i.e. pick < num).
1: The number I picked is higher than your guess (i.e. pick > num).
0: The number I picked is equal to your guess (i.e. pick == num).
Return the number that I picked.

Example 1:
Input: n = 10, pick = 6
Output: 6

Example 2:
Input: n = 1, pick = 1
Output: 1
*********** CODE ***************
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -> int:

def guessNumber(self, n: int) -> int:
    min, max = 1, n
    while min <= max:
        mid = (min + max) // 2
        res = guess(mid)
        if res == 0:
            return mid
        elif res == -1:
            max = mid - 1
        else:
            min = mid + 1
    return -1

*********** CODE ***************
The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).

Example 1:
Input: n = 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.

Example 2:
Input: n = 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.
*********** CODE ***************

# Memoizing = remember the old values you've computed so you don't recompute them again
    def fib(self, n: int) -> int:
        computedValues = {}
        return self.memoizedFib(n, computedValues):
        
    def memoizedFib(self, n, computedValues):
        if n in computedValues:
            return computedValues[n]
        computedValues[n] = self.memoizedFib(n - 1, computedValues) + self.memoizedFib(n - 2, computedValues)
        return computedValues[n]
    
    def dumbFib(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        return self.fib(n - 1) + self.fib(n - 2)

*********** CODE ***************
For a given positive integer n determine if it can be represented as a sum of two Fibonacci numbers (possibly equal).

Example
For n = 1, the output should be
fibonacciSimpleSum2(n) = true.

Explanation: 1 = 0 + 1 = F0 + F1.

For n = 11, the output should be
fibonacciSimpleSum2(n) = true.

Explanation: 11 = 3 + 8 = F4 + F6.
*********** CODE ***************



*********** CODE ***************
Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search for target in nums. If target exists, then return its index, otherwise, return -1.

Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1

Note:
All elements in nums are unique.
The length of nums will be <= 100
The value of each element in nums will be in the range [1, 10000]
*********** CODE ***************

def csBinarySearch(nums, target):
    min, max = 0, len(nums) - 1
    while min <= max:
        mid = (min + max) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            min = mid + 1
        else:
            max = mid - 1
    return -1

*********** CODE ***************
Given an integer array nums sorted in ascending order, and an integer target.
Suppose that nums is rotated at some pivot unknown to you beforehand (i.e., [1,2,3,4,5,6,7] might become [4,5,6,7,1,2,3]).
You should search for target in nums and if found return its index, otherwise return -1.

Example 1:
Input: nums = [6,7,1,2,3,4,5], target = 1
Output: 2

Example 2:
Input: nums = [6,7,1,2,3,4,5], target = 3
Output: 4
*********** CODE ***************

def csSearchRotatedSortedArray(nums, target):
    for i in range(len(nums)):
        if nums[i] == target:
            return i
    return -1

*********** CODE ***************
Two words are blanagrams if they are anagrams but exactly one letter has been substituted for another.
Given two words, check if they are blanagrams of each other.

Example
For word1 = "tangram" and word2 = "anagram", the output should be
checkBlanagrams(word1, word2) = true;
After changing the first letter 't' to 'a' in the word1, the words become anagrams.
*********** CODE ***************

from collections import Counter

def checkBlanagrams(word1, word2):
    ct1, ct2 = Counter(word1), Counter(word2)
    return sum((ct1 - ct2).values()) == 1 and sum((ct2 - ct1).values()) == 1

*********** CODE ***************
You are given a sorted array in ascending order that is rotated at some unknown pivot (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]) and a target value.
Write a function that returns the target value's index. If the target value is not present in the array, return -1.
You may assume no duplicate exists in the array.
Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Example 2:
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
*********** CODE ***************

def findValueSortedShiftedArray(nums, target):
    for i in range(len(nums)):
        if nums[i] == target:
            return i
    return -1

*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************

*********** CODE ***************



*********** CODE ***************
